{"version":3,"file":"main.bundle.js","mappings":"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;AAAA;AACA;AADA;AAAA;;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAHA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AACA;AArBA;AAuBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AAEA;AAAA;;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AA3CA;AA6CA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AADA;AAIA;;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAIA;AACA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAFA;;AAMA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AAvDA;AA3EA;AAqIA;;AAEA;;;;;;;;;;;AC7JA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://prose-mirror-react-wrapper/./src/demo/index.tsx","webpack://prose-mirror-react-wrapper/./src/lib/App.tsx","webpack://prose-mirror-react-wrapper/./src/lib/components/Editor/Editor.tsx","webpack://prose-mirror-react-wrapper/./src/lib/components/Editor/buildMenu.ts","webpack://prose-mirror-react-wrapper/./src/lib/components/Editor/cut.ts","webpack://prose-mirror-react-wrapper/./src/lib/components/Editor/index.ts","webpack://prose-mirror-react-wrapper/./src/lib/components/Popup/Popup.tsx","webpack://prose-mirror-react-wrapper/./src/lib/components/Popup/View.tsx","webpack://prose-mirror-react-wrapper/./src/lib/components/Popup/index.ts","webpack://prose-mirror-react-wrapper/./src/lib/index.tsx","webpack://prose-mirror-react-wrapper/./src/lib/plugins/autocomplete/AutocompletePopup.tsx","webpack://prose-mirror-react-wrapper/./src/lib/plugins/autocomplete/autocomplete.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/autocomplete/dataProvider.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/autocomplete/helpers.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/autocomplete/index.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/autocomplete/key.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/spellchecker/SpellcheckerPopup.tsx","webpack://prose-mirror-react-wrapper/./src/lib/plugins/spellchecker/dataProvider.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/spellchecker/helpers.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/spellchecker/index.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/spellchecker/key.ts","webpack://prose-mirror-react-wrapper/./src/lib/plugins/spellchecker/spellchecker.tsx","webpack://prose-mirror-react-wrapper/./src/lib/components/Editor/index.css?4ae3","webpack://prose-mirror-react-wrapper/./src/lib/components/Popup/index.css?bf19","webpack://prose-mirror-react-wrapper/./src/lib/index.css?2e69","webpack://prose-mirror-react-wrapper/./src/lib/plugins/spellchecker/index.css?bf6f","webpack://prose-mirror-react-wrapper/webpack/bootstrap","webpack://prose-mirror-react-wrapper/webpack/runtime/chunk loaded","webpack://prose-mirror-react-wrapper/webpack/runtime/compat get default export","webpack://prose-mirror-react-wrapper/webpack/runtime/define property getters","webpack://prose-mirror-react-wrapper/webpack/runtime/hasOwnProperty shorthand","webpack://prose-mirror-react-wrapper/webpack/runtime/make namespace object","webpack://prose-mirror-react-wrapper/webpack/runtime/jsonp chunk loading","webpack://prose-mirror-react-wrapper/webpack/before-startup","webpack://prose-mirror-react-wrapper/webpack/startup","webpack://prose-mirror-react-wrapper/webpack/after-startup"],"sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\n// import \"./styles/styles.scss\";\n// import \"./styles/pagination.scss\";\n\nimport ProseMirror from \"./../lib/index\";\n\nconst root = document.getElementById(\"react-root\");\n\nReactDOM.render(\n  <div>\n    <ProseMirror />\n  </div>,\n  root\n);\n\nif (module.hot) {\n  module.hot.accept();\n}\n","import \"./index.css\";\n\nimport React, { useCallback, useRef } from \"react\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport createSpellcheckPlugin, {\n  SpellcheckerPopup\n} from \"./plugins/spellchecker\";\nimport createAutocompletePlugin, {\n  AutocompletePopup\n} from \"./plugins/autocomplete\";\n\nimport Editor from \"./components/Editor\";\n\nconst App = () => {\n  const plugins = useRef([\n    createSpellcheckPlugin(),\n    createAutocompletePlugin()\n  ]);\n\n  const renderPluginsViews = useCallback(\n    (state: EditorState) => (\n      <>\n        <SpellcheckerPopup state={state} />\n        <AutocompletePopup state={state} />\n      </>\n    ),\n    []\n  );\n\n  return (\n    <div className=\"App\">\n      <Editor\n        className=\"ProseMirror\"\n        plugins={plugins.current}\n        renderPluginsViews={renderPluginsViews}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","import \"prosemirror-view/style/prosemirror.css\";\nimport \"prosemirror-menu/style/menu.css\";\nimport \"./index.css\";\n\nimport React, { useRef } from \"react\";\nimport { schema } from \"prosemirror-schema-basic\";\nimport { keymap } from \"prosemirror-keymap\";\nimport { baseKeymap } from \"prosemirror-commands\";\nimport { useProseMirror, ProseMirror } from \"use-prosemirror\";\nimport { EditorState, Plugin, StateField } from \"prosemirror-state\";\n\nimport { menuBar } from \"prosemirror-menu\";\n\nimport buildMenu from \"./buildMenu\";\n\ninterface EditorProps {\n  plugins: Plugin<StateField, any>[];\n  renderPluginsViews: (_state: EditorState) => JSX.Element;\n  className?: string;\n}\n\nconst Editor = ({\n  plugins,\n  renderPluginsViews,\n  className = null\n}: EditorProps) => {\n  const opts = useRef<Parameters<typeof useProseMirror>[0]>({\n    schema: schema,\n    plugins: [\n      menuBar({\n        floating: true,\n        content: buildMenu(schema).fullMenu\n      }),\n      ...plugins,\n\n      keymap({\n        ...baseKeymap\n      })\n    ]\n  });\n\n  const [state, setState] = useProseMirror(opts.current);\n\n  return (\n    <div className=\"ProseMirrorContainer\">\n      <ProseMirror className={className} state={state} onChange={setState} />\n      {renderPluginsViews(state)}\n    </div>\n  );\n};\n\nexport default Editor;\n","import { Command, toggleMark } from \"prosemirror-commands\";\nimport { MarkType, Schema, NodeType } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport {\n  blockTypeItem,\n  Dropdown,\n  DropdownSubmenu,\n  icons,\n  MenuItem,\n  MenuElement,\n  MenuItemSpec\n} from \"prosemirror-menu\";\n\nimport cut from \"./cut\";\n\nfunction cmdItem(cmd: Command, options: Partial<MenuItemSpec>) {\n  const passedOptions: MenuItemSpec = {\n    label: options.title as string | undefined,\n    run: cmd\n  };\n  for (const prop in options)\n    (passedOptions as any)[prop] = (options as any)[prop];\n  if (!options.enable && !options.select)\n    passedOptions[options.enable ? \"enable\" : \"select\"] = state => cmd(state);\n\n  return new MenuItem(passedOptions);\n}\n\nfunction markActive(state: EditorState, type: MarkType) {\n  const { from, $from, to, empty } = state.selection;\n  if (empty) return !!type.isInSet(state.storedMarks || $from.marks());\n  else return state.doc.rangeHasMark(from, to, type);\n}\n\nfunction markItem(markType: MarkType, options: Partial<MenuItemSpec>) {\n  const passedOptions: Partial<MenuItemSpec> = {\n    active(state) {\n      return markActive(state, markType);\n    }\n  };\n  for (const prop in options)\n    (passedOptions as any)[prop] = (options as any)[prop];\n  return cmdItem(toggleMark(markType), passedOptions);\n}\n\ntype MenuItemResult = {\n  /// A menu item to toggle the [strong mark](#schema-basic.StrongMark).\n  toggleStrong?: MenuItem;\n\n  /// A menu item to toggle the [emphasis mark](#schema-basic.EmMark).\n  toggleEm?: MenuItem;\n\n  /// A menu item to set the current textblock to be a normal\n  /// [paragraph](#schema-basic.Paragraph).\n  makeParagraph?: MenuItem;\n\n  /// Menu items to set the current textblock to be a\n  /// [heading](#schema-basic.Heading) of level _N_.\n  makeHead1?: MenuItem;\n  makeHead2?: MenuItem;\n  makeHead3?: MenuItem;\n  makeHead4?: MenuItem;\n  makeHead5?: MenuItem;\n  makeHead6?: MenuItem;\n\n  /// A menu item to set the current textblock to be a\n  /// [code block](#schema-basic.CodeBlock).\n  makeCodeBlock?: MenuItem;\n\n  /// Inline-markup related menu items.\n  inlineMenu: MenuElement[][];\n\n  /// A dropdown containing the items for making the current\n  /// textblock a paragraph, code block, or heading.\n  typeMenu: Dropdown;\n\n  /// An array of arrays of menu elements for use as the full menu\n  /// for, for example the [menu\n  /// bar](https://github.com/prosemirror/prosemirror-menu#user-content-menubar).\n  fullMenu: MenuElement[][];\n};\n\n/// Given a schema, look for default mark and node types in it and\n/// return an object with relevant menu items relating to those marks.\nfunction buildMenu(schema: Schema): MenuItemResult {\n  const r: MenuItemResult = {} as any;\n  let mark: MarkType | undefined;\n  if ((mark = schema.marks.strong))\n    r.toggleStrong = markItem(mark, {\n      title: \"Toggle strong style\",\n      icon: icons.strong\n    });\n  if ((mark = schema.marks.em))\n    r.toggleEm = markItem(mark, { title: \"Toggle emphasis\", icon: icons.em });\n\n  let node: NodeType | undefined;\n\n  if ((node = schema.nodes.paragraph))\n    r.makeParagraph = blockTypeItem(node, {\n      title: \"Change to paragraph\",\n      label: \"Plain\"\n    });\n\n  if ((node = schema.nodes.heading))\n    for (let i = 1; i <= 10; i++)\n      (r as any)[\"makeHead\" + i] = blockTypeItem(node, {\n        title: \"Change to heading \" + i,\n        label: \"Level \" + i,\n        attrs: { level: i }\n      });\n\n  r.typeMenu = new Dropdown(\n    cut([\n      r.makeParagraph,\n      r.makeCodeBlock,\n      r.makeHead1 &&\n        new DropdownSubmenu(\n          cut([\n            r.makeHead1,\n            r.makeHead2,\n            r.makeHead3,\n            r.makeHead4,\n            r.makeHead5,\n            r.makeHead6\n          ]),\n          { label: \"Heading\" }\n        )\n    ]),\n    { label: \"Type...\" }\n  );\n\n  r.inlineMenu = [cut([r.toggleStrong, r.toggleEm])];\n\n  r.fullMenu = r.inlineMenu.concat([[r.typeMenu]]);\n\n  return r;\n}\n\nexport default buildMenu;\n","export default <T>(arr: T[]) => arr.filter(x => x) as NonNullable<T>[];\n","export { default } from \"./Editor\";\n","import \"./index.css\";\n\nimport React from \"react\";\n\nimport { ScreenPosition } from \"../../types\";\n\nimport View from \"./View\";\n\ninterface Props {\n  isVisible: boolean;\n  items: string[];\n  screenPosition: ScreenPosition;\n  clickHandler: (_correction: string) => void;\n}\n\nconst Popup = ({\n  isVisible,\n  screenPosition,\n  items,\n  clickHandler: clickHandlerProp\n}: Props) => {\n  const clickHandler = (event: React.MouseEvent) => {\n    const target = event.target as HTMLElement;\n\n    if (target.tagName === \"LI\") {\n      const value = target.innerText;\n      clickHandlerProp(value);\n    }\n  };\n\n  return (\n    <>\n      {isVisible && (\n        <View clickHandler={clickHandler} position={screenPosition}>\n          <ul>\n            {items.map(item => (\n              <li value={item} key={item} className=\"popupItem\">\n                {item}\n              </li>\n            ))}\n          </ul>\n        </View>\n      )}\n      {isVisible && items.length === 0 && (\n        <View position={screenPosition}>\n          <div className=\"emptyList\">No options were provided</div>\n        </View>\n      )}\n    </>\n  );\n};\n\nexport default Popup;\n","import React, { PropsWithChildren, useState } from \"react\";\nimport { usePopper } from \"react-popper\";\n\nimport { ScreenPosition } from \"../../types\";\n\ninterface Props {\n  clickHandler?: (_event: React.MouseEvent) => void;\n  position: ScreenPosition;\n}\n\nconst View = ({\n  clickHandler = () => {},\n  position,\n  children\n}: PropsWithChildren<Props>) => {\n  const [referenceElement, setReferenceElement] = useState(null);\n  const [popperElement, setPopperElement] = useState(null);\n  const [arrowElement, setArrowElement] = useState(null);\n  const { styles, attributes } = usePopper(referenceElement, popperElement, {\n    modifiers: [{ name: \"arrow\", options: { element: arrowElement } }]\n  });\n\n  return (\n    <>\n      <div\n        className=\"popupAnchor\"\n        style={{ top: position.y, left: position.x }}\n        ref={setReferenceElement}\n      />\n\n      <div ref={setPopperElement} style={styles.popper} {...attributes.popper}>\n        <div className=\"popup\" onClick={clickHandler}>\n          {children}\n        </div>\n        <div ref={setArrowElement} style={styles.arrow} />\n      </div>\n    </>\n  );\n};\n\nexport default View;\n","export { default } from \"./Popup\";\n","export { default } from \"./App\";\n","import React from \"react\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport Popup from \"../../components/Popup\";\n\nimport key from \"./key\";\nimport { AutocompletePluginState } from \"./types\";\n\ninterface Props {\n  state: EditorState;\n}\n\nconst SpellcheckerPopup = ({ state }: Props) => {\n  const {\n    isPopupVisible: isVisible,\n    clickHandler = () => {},\n    screenPosition,\n    candidates\n  } = key.getState(state) as AutocompletePluginState;\n\n  return (\n    <Popup\n      isVisible={isVisible}\n      screenPosition={screenPosition}\n      items={candidates}\n      clickHandler={clickHandler}\n    />\n  );\n};\n\nexport default SpellcheckerPopup;\n","import { Plugin, TextSelection } from \"prosemirror-state\";\nimport { Mark } from \"prosemirror-model\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport { ScreenPosition } from \"../../types\";\n\nimport { SelectedRange } from \"../types\";\n\nimport type { DataProvider } from \"../dataProvider\";\n\nimport { AutocompletePluginState } from \"./types\";\nimport LocalDataProvider from \"./dataProvider\";\nimport { createCorrectionFunction, checkPosition } from \"./helpers\";\nimport key from \"./key\";\n\nfunction createAutocompletePlugin(\n  dataProvider: DataProvider<string, string[]> = new LocalDataProvider()\n) {\n  return new Plugin<AutocompletePluginState>({\n    key,\n\n    state: {\n      init() {\n        return {\n          docChanged: false,\n          isPopupVisible: false,\n          screenPosition: null,\n          clickHandler: null,\n          selectedRange: null,\n          candidates: [],\n          cursorDeco: null,\n          ...this.spec.state\n        };\n      },\n      apply(tr, prev) {\n        const meta = tr.getMeta(this.spec.key);\n\n        const isPopupVisible = meta?.isPopupVisible ?? prev.isPopupVisible;\n        const selectedRange = meta?.selectedRange ?? prev.selectedRange;\n        const screenPosition = meta?.screenPosition ?? prev.screenPosition;\n        const clickHandler = meta?.clickHandler ?? prev.clickHandler;\n        const candidates = meta?.candidates ?? prev.candidates;\n\n        return {\n          ...prev,\n          docChanged: tr.docChanged,\n          isPopupVisible,\n          screenPosition,\n          clickHandler,\n          candidates,\n          selectedRange\n        };\n      }\n    },\n    props: {\n      handleClick(view: EditorView) {\n        view.dispatch(\n          view.state.tr.setMeta(this.spec.key, {\n            isPopupVisible: false\n          })\n        );\n        return false;\n      },\n      handleKeyDown(view: EditorView, event: KeyboardEvent) {\n        const currectState = this.spec.key.getState(view.state);\n\n        dataProvider.getAbortionController.abort();\n\n        if (event.key !== \"Tab\") {\n          if (currectState.isPopupVisible) {\n            view.dispatch(\n              view.state.tr.setMeta(this.spec.key, {\n                isPopupVisible: false\n              })\n            );\n          }\n        } else {\n          if (view.state.selection.empty) {\n            const {\n              $cursor: { pos: cursorPositions }\n            } = view.state.selection as TextSelection;\n\n            checkPosition(\n              view,\n              cursorPositions,\n              (\n                word: string,\n                marks: Mark[],\n                screenPosition: ScreenPosition,\n                range: SelectedRange\n              ) => {\n                dataProvider.requestData(word).then(results => {\n                  if (results.length) {\n                    view.dispatch(\n                      view.state.tr.setMeta(this.spec.key, {\n                        isPopupVisible: true,\n                        screenPosition,\n                        candidates: results,\n                        clickHandler: createCorrectionFunction(\n                          view,\n                          range,\n                          marks\n                        )\n                      })\n                    );\n                  }\n                });\n              }\n            );\n          }\n\n          return true;\n        }\n      }\n    }\n  });\n}\n\nexport default createAutocompletePlugin;\n","import type {\n  DataProvider,\n  DataProviderAbortionController\n} from \"../dataProvider\";\n\nconst DICTIONARY = [\n  \"donkey\",\n  \"dolphin\",\n  \"dog\",\n  \"zebra\",\n  \"snake\",\n  \"snail\",\n  \"sparrow\",\n  \"spider\",\n  \"shark\",\n  \"lion\",\n  \"lobster\",\n  \"lizard\",\n  \"lama\",\n  \"locust\",\n  \"cat\",\n  \"rabbit\",\n  \"giraffi\",\n  \"horse\"\n];\n\ninterface LocalDataProviderAbortionController\n  extends DataProviderAbortionController {\n  timerId: ReturnType<typeof setTimeout>;\n}\n\nclass LocalDataProvider implements DataProvider<string, string[]> {\n  private localDictionary: Record<string, string[]> = {};\n  private abortionController: LocalDataProviderAbortionController = {\n    timerId: null,\n    abort: function () {\n      if (this.timerId !== null) {\n        clearTimeout(this.timerId);\n      }\n    }.bind(this)\n  };\n\n  get getAbortionController(): DataProviderAbortionController {\n    return this.abortionController;\n  }\n\n  requestData(token: string) {\n    this.abortionController.abort();\n\n    return new Promise<string[]>(\n      function (resolve: any) {\n        if (this.localDictionary[token]) {\n          resolve(this.localDictionary[token]);\n        } else {\n          // Emulating the network request\n          this.abortionController.timerId = setTimeout(\n            function () {\n              this.abortionController.timerId = null;\n\n              const results = DICTIONARY.filter(\n                key =>\n                  key.length > token.length &&\n                  key.startsWith(token.toLowerCase())\n              );\n\n              // Do the local caching\n              this.localDictionary[token] = results;\n\n              resolve(results);\n            }.bind(this),\n            2000\n          );\n        }\n      }.bind(this)\n    );\n  }\n}\n\nexport default LocalDataProvider;\nexport { DataProvider };\n","import { Mark, Node } from \"prosemirror-model\";\nimport { TextSelection } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\nimport { ReplaceStep } from \"prosemirror-transform\";\n\nimport { SelectedRange } from \"../types\";\nimport { ScreenPosition } from \"../../types\";\n\nimport key from \"./key\";\n\n/**\n *\n * Creates the function that will be used to replace the word with the correction\n *\n **/\n\nexport function createCorrectionFunction(\n  view: EditorView,\n  { from, to }: SelectedRange,\n  marks?: Mark[]\n) {\n  return (correction: string) => {\n    let transaction = view.state.tr.replaceWith(\n      from,\n      to,\n      view.state.schema.text(correction, marks)\n    );\n    const step = transaction.steps[0] as ReplaceStep;\n    const map = step.getMap();\n    const stepTo = map.map(step.to, 1);\n    transaction = transaction.setSelection(\n      TextSelection.create(transaction.doc, stepTo)\n    );\n    transaction.setMeta(key, {\n      isPopupVisible: false\n    });\n    view.dispatch(transaction);\n    view.focus();\n  };\n}\n\n/**\n * Function to check and react on autocomplete initiation event\n * Finds the node by the position of the cursor and checks if it is a word calling a callback function after this\n */\n\nexport function checkPosition(\n  view: EditorView,\n  position: number,\n  callback: (\n    _word: string,\n    _marks: Mark[],\n    _screenPosition: ScreenPosition,\n    _range: SelectedRange\n  ) => void\n) {\n  const { node, from, to } = getNodeByPosition(view.state.doc, position);\n\n  const token = view.state.doc.textBetween(from, to, \" \");\n\n  const letterRegEx = /\\w/g;\n  const matchLetter =\n    token.length > 0 ? token[token.length - 1].match(letterRegEx) : null;\n\n  if (position === to && matchLetter !== null) {\n    const word = getLastWordFromNode(node);\n\n    const cursorViewPortPosition = view.coordsAtPos(position);\n\n    const screenPosition: ScreenPosition = {\n      x: cursorViewPortPosition.left,\n      y: cursorViewPortPosition.bottom + 4\n    };\n\n    const range: SelectedRange = {\n      from: to - word.length,\n      to: to\n    };\n\n    callback(word, node.marks as Mark[], screenPosition, range);\n  }\n}\n\nexport function getLastWordFromNode(node: Node) {\n  const wordRegEx = /\\w+/g;\n  const matchWord = node.text.match(wordRegEx);\n\n  return matchWord[matchWord.length - 1];\n}\n\nexport function getNodeByPosition(doc: Node, position: number) {\n  const resolvedPos = doc.resolve(position);\n  const parentInfo = resolvedPos.parent.childBefore(resolvedPos.parentOffset);\n  const node = parentInfo.node;\n  const nodeStartPos = parentInfo.offset;\n  const posInParent = resolvedPos.parentOffset;\n  const offsetInLink = posInParent - nodeStartPos;\n  const nodeFrom = position - offsetInLink;\n  const nodeTo = nodeFrom + node.nodeSize;\n\n  return { node, from: nodeFrom, to: nodeTo };\n}\n","export type { DataProvider } from \"./dataProvider\";\n\nexport { default } from \"./autocomplete\";\n\nexport { default as AutocompletePopup } from \"./AutocompletePopup\";\n","import { PluginKey } from \"prosemirror-state\";\n\nexport default new PluginKey(\"autocomplete-plugin\");\n","import React from \"react\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport Popup from \"../../components/Popup\";\n\nimport key from \"./key\";\nimport { SpellcheckerPluginState } from \"./types\";\n\ninterface Props {\n  state: EditorState;\n}\n\nconst SpellcheckerPopup = ({ state }: Props) => {\n  const {\n    isPopupVisible: isVisible,\n    selectedRange,\n    screenPosition,\n    clickHandler = () => {},\n    errorMap\n  } = key.getState(state) as SpellcheckerPluginState;\n\n  const keyForErrorMap = `${selectedRange?.from}-${selectedRange?.to}`;\n\n  return (\n    <Popup\n      isVisible={isVisible}\n      screenPosition={screenPosition}\n      items={errorMap[keyForErrorMap] ?? []}\n      clickHandler={clickHandler}\n    />\n  );\n};\n\nexport default SpellcheckerPopup;\n","import type {\n  DataProvider,\n  DataProviderAbortionController\n} from \"../dataProvider\";\n\nimport { Word, Error } from \"./types\";\n\nconst DICTIONARY = [\n  \"donkey\",\n  \"dolphin\",\n  \"dog\",\n  \"zebra\",\n  \"snake\",\n  \"snail\",\n  \"sparrow\",\n  \"spider\",\n  \"shark\",\n  \"lion\",\n  \"lobster\",\n  \"lizard\",\n  \"lama\",\n  \"locust\",\n  \"cat\",\n  \"rabbit\",\n  \"giraffi\",\n  \"horse\"\n];\n\ninterface LocalDataProviderAbortionController\n  extends DataProviderAbortionController {\n  timerId: ReturnType<typeof setTimeout>;\n}\n\nconst suggester = (token: string) => {\n  const result = new Set<string>();\n  const dict = [...DICTIONARY];\n  for (let i = 1; i < token.length; i++) {\n    const char = token.slice(0, i);\n    const words = dict.filter(d => d.startsWith(char));\n    words.forEach(word => {\n      if (word.length > token.length - 2 && word.length < token.length + 2)\n        result.add(word);\n    });\n  }\n\n  return Array.from(result);\n};\n\nexport default class LocalDataProvider\n  implements DataProvider<Word[], Error[]>\n{\n  private abortionController: LocalDataProviderAbortionController = {\n    timerId: null,\n    abort: function () {\n      if (this.timerId !== null) {\n        clearTimeout(this.timerId);\n      }\n    }.bind(this)\n  };\n\n  get getAbortionController(): DataProviderAbortionController {\n    return this.abortionController;\n  }\n\n  requestData(words: Word[]) {\n    this.abortionController.abort();\n\n    return new Promise<Error[]>(\n      function (resolve: any) {\n        this.abortionController.timerId = setTimeout(function () {\n          const errors: Error[] = [];\n\n          for (let i = 0; i < words.length; i++) {\n            const word = words[i];\n            if (!DICTIONARY.includes(word.text)) {\n              const candidates = suggester(word.text);\n              errors.push({ ...word, correction: candidates });\n            }\n          }\n          resolve(errors);\n        }, 2000);\n      }.bind(this)\n    );\n  }\n}\n","import { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { TextSelection } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\nimport { Node } from \"prosemirror-model\";\n\nimport { SelectedRange } from \"../types\";\n\nimport { Word, Error, ErrorMap } from \"./types\";\nimport key from \"./key\";\n\n/**\n * Traverses the document and returns each words in the document separately with its borders.\n */\n\nexport function gatherAllWords(doc: Node) {\n  const words: Word[] = [];\n\n  function record(text: string, from: number, to: number) {\n    words.push({ text, from, to });\n  }\n\n  // For each node in the document\n  doc.descendants((node: Node, pos: number) => {\n    if (node.isText) {\n      const wordRegEx = /\\w+/g;\n      let match = null;\n      // Scan text nodes for suspicious patterns\n      while ((match = wordRegEx.exec(node.text)))\n        record(\n          match[0],\n          doc.resolve(pos + match.index).pos,\n          doc.resolve(pos + match.index + match[0].length).pos\n        );\n    }\n  });\n\n  return words;\n}\n\n/**\n *\n * Creates a map of errors for a given document.\n * Maps helps to compare the ragne in the doc with the suggested variants of replacement.\n *\n */\n\nexport function createErrorMap(errors: Error[]) {\n  const map = {} as ErrorMap;\n  errors.forEach(error => {\n    if (error.correction.length) {\n      const key = `${error.from}-${error.to}`;\n      map[key] = error.correction;\n    }\n  });\n\n  return map;\n}\n\nexport function createDecorations(errors: Word[], doc: Node) {\n  const decos: Decoration[] = [];\n  errors.forEach(prob => {\n    decos.push(Decoration.inline(prob.from, prob.to, { class: \"spellError\" }));\n  });\n  return DecorationSet.create(doc, decos);\n}\n\n/**\n *\n * Creates the function that will be used to replace the word with the correction\n *\n **/\n\nexport function createCorrectionFunction(\n  view: EditorView,\n  { from, to }: SelectedRange\n) {\n  return (correction: string) => {\n    let transaction = view.state.tr.replaceWith(\n      from,\n      to,\n      view.state.schema.text(correction)\n    );\n    const $newPos = transaction.doc.resolve(\n      transaction.mapping.map(from + correction.length)\n    );\n    transaction = transaction.setSelection(new TextSelection($newPos, $newPos));\n    transaction.setMeta(key, {\n      isPopupVisible: false\n    });\n    view.dispatch(transaction);\n\n    view.focus();\n  };\n}\n\n/**\n *\n * Cheap version of debouncer. Works only for one function\n *\n * **/\n\nexport const debouncedCall = (function () {\n  let timerId: ReturnType<typeof setTimeout> | null = null;\n\n  return function (callback: () => void, timeout = 5000) {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n\n    timerId = setTimeout(() => {\n      clearTimeout(timerId);\n      callback();\n    }, timeout);\n  };\n})();\n","export { default } from \"./spellchecker\";\nexport { default as SpellcheckerPopup } from \"./SpellcheckerPopup\";\n","import { PluginKey } from \"prosemirror-state\";\n\nexport default new PluginKey(\"spellchecker-plugin\");\n","import \"./index.css\";\nimport { DecorationSet } from \"prosemirror-view\";\nimport { Plugin, EditorState } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport { SelectedRange } from \"../types\";\n\nimport { Word, Error, SpellcheckerPluginState } from \"./types\";\nimport LocalDataProvider from \"./dataProvider\";\nimport type { DataProvider } from \"../dataProvider\";\nimport {\n  debouncedCall,\n  gatherAllWords,\n  createDecorations,\n  createErrorMap,\n  createCorrectionFunction\n} from \"./helpers\";\nimport key from \"./key\";\n\nfunction createAutocompletePlugin(\n  dataProvider: DataProvider<Word[], Error[]> = new LocalDataProvider()\n) {\n  return new Plugin<SpellcheckerPluginState>({\n    key,\n    view(view) {\n      (view.dom as HTMLDivElement).spellcheck = false;\n      const pluginKey = this.key;\n      return {\n        update(editor) {\n          const nextPluginState = pluginKey.getState(editor.state);\n\n          if (nextPluginState.docChanged) {\n            dataProvider.getAbortionController.abort();\n            debouncedCall(async () => {\n              const words = gatherAllWords(editor.state.doc);\n              const errors = await dataProvider.requestData(words);\n              const decorations = createDecorations(errors, editor.state.doc);\n              const errorMap = createErrorMap(errors);\n\n              editor.dispatch(\n                editor.state.tr.setMeta(pluginKey, {\n                  decorations,\n                  errors,\n                  errorMap\n                })\n              );\n            }, 2000);\n          }\n        }\n      };\n    },\n\n    state: {\n      init() {\n        return {\n          docChanged: false,\n          isPopupVisible: false,\n          decoration: DecorationSet.empty,\n          errors: [],\n          errorMap: {},\n          screenPosition: null,\n          clickHandler: null,\n          selectedRange: null,\n          cursorDeco: null,\n          ...this.spec.state\n        };\n      },\n\n      apply(tr, prev) {\n        const meta = tr.getMeta(this.spec.key);\n\n        const decoration = tr.docChanged\n          ? DecorationSet.empty\n          : meta?.decorations ?? prev.decoration;\n\n        const errors = meta?.errors ?? prev.errors;\n        const errorMap = meta?.errorMap ?? prev.errorMap;\n        const selectedRange = meta?.selectedRange ?? prev.selectedRange;\n\n        const isPopupVisible = meta?.isPopupVisible ?? prev.isPopupVisible;\n\n        const screenPosition = meta?.screenPosition ?? prev.screenPosition;\n        const clickHandler = meta?.clickHandler ?? prev.clickHandler;\n\n        return {\n          ...prev,\n          docChanged: tr.docChanged,\n          decoration,\n          errors,\n          isPopupVisible,\n          screenPosition,\n          clickHandler,\n          selectedRange,\n          errorMap\n        };\n      }\n    },\n    props: {\n      decorations(state: EditorState) {\n        const { decoration } = this.getState(state);\n        return decoration;\n      },\n      handleKeyDown(view: EditorView) {\n        const currectState = this.spec.key.getState(view.state);\n\n        if (currectState.isPopupVisible) {\n          view.dispatch(\n            view.state.tr.setMeta(this.spec.key, {\n              isPopupVisible: false\n            })\n          );\n        }\n        return false;\n      },\n      handleClick(view: EditorView, pos: number, event: MouseEvent) {\n        if (!event.altKey) {\n          view.dispatch(\n            view.state.tr.setMeta(this.spec.key, {\n              isPopupVisible: false\n            })\n          );\n        } else {\n          const { decoration } = this.getState(view.state);\n          const deco = decoration.find(pos, pos)[0];\n          if (!deco) return;\n\n          const $from = view.state.doc.resolve(deco.from);\n          const from = deco.from - $from.start();\n          const to = deco.to - $from.start();\n\n          const coords = view.coordsAtPos(pos);\n\n          const screenPosition = {\n            x: coords.left,\n            y: coords.bottom - 4\n          };\n\n          // Я понимаю что тут видимо как-то нужно использовать map, но не очень понимаю как именно\n          const range: SelectedRange = { from: from + 1, to: to + 1 };\n\n          view.dispatch(\n            view.state.tr.setMeta(this.spec.key, {\n              isPopupVisible: true,\n              screenPosition,\n              clickHandler: createCorrectionFunction(view, range),\n              selectedRange: range\n            })\n          );\n\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n  });\n}\n\nexport default createAutocompletePlugin;\n","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkprose_mirror_react_wrapper\"] = self[\"webpackChunkprose_mirror_react_wrapper\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendor\"], () => (__webpack_require__(\"./src/demo/index.tsx\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}